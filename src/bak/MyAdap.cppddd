#include "MyAdapt.hpp"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
////                  EnumCvt
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
EnumCvt::EnumCvt() {}
EnumCvt::~EnumCvt() {}
//////////////////////////////////////////////////////
////                   my enum
//////////////////////////////////////////////////////
SYNC_TYPE EnumCvt::String2Enum_SYNC_TYPE(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "SYNC_TYPE_INVALID"))
        return SYNC_TYPE_INVALID;
    else if (0 == strcmp(strEnum.c_str(), "SYNC_TYPE_MAIN_TO_DATAPUT"))
        return SYNC_TYPE_MAIN_TO_DATAPUT;
    else if (0 == strcmp(strEnum.c_str(), "SYNC_TYPE_DATAPUT_TO_CALLBACK"))
        return SYNC_TYPE_DATAPUT_TO_CALLBACK;
    else {
        LOG_ERROR("Input SYNC_TYPE strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(SYNC_TYPE enumInput) {
    if (SYNC_TYPE_INVALID == enumInput)
        return "SYNC_TYPE_INVALID";
    else if (SYNC_TYPE_MAIN_TO_DATAPUT == enumInput)
        return "SYNC_TYPE_MAIN_TO_DATAPUT";
    else if (SYNC_TYPE_DATAPUT_TO_CALLBACK == enumInput)
        return "SYNC_TYPE_DATAPUT_TO_CALLBACK";
    else {
        LOG_ERROR("Input SYNC_TYPE enum Error!\n");
        exit(1);
    }
}
SDK_MODULE EnumCvt::String2Enum_SDK_MODULE(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "SDK_MODULE_INVALID"))
        return SDK_MODULE_INVALID;
    else if (0 == strcmp(strEnum.c_str(), "SDK_MODULE_DMS"))
        return SDK_MODULE_DMS;
    else if (0 == strcmp(strEnum.c_str(), "SDK_MODULE_OMS"))
        return SDK_MODULE_OMS;
    else if (0 == strcmp(strEnum.c_str(), "SDK_MODULE_DMS_FACEID"))
        return SDK_MODULE_DMS_FACEID;
    else if (0 == strcmp(strEnum.c_str(), "SDK_MODULE_OMS_FACEID"))
        return SDK_MODULE_OMS_FACEID;
    else {
        LOG_ERROR("Input SDK_MODULE strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(SDK_MODULE enumInput) {
    if (SDK_MODULE_INVALID == enumInput)
        return "SDK_MODULE_INVALID";
    else if (SDK_MODULE_DMS == enumInput)
        return "SDK_MODULE_DMS";
    else if (SDK_MODULE_OMS == enumInput)
        return "SDK_MODULE_OMS";
    else if (SDK_MODULE_DMS_FACEID == enumInput)
        return "SDK_MODULE_DMS_FACEID";
    else if (SDK_MODULE_OMS_FACEID == enumInput)
        return "SDK_MODULE_OMS_FACEID";
    else {
        LOG_ERROR("Input SDK_MODULE enum Error!\n");
        exit(1);
    }
}
RUN_MODULE EnumCvt::String2Enum_RUN_MODULE(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "RUN_MODULE_INVALID"))
        return RUN_MODULE_INVALID;
    else if (0 == strcmp(strEnum.c_str(), "RUN_MODULE_MP4"))
        return RUN_MODULE_MP4;
    else if (0 == strcmp(strEnum.c_str(), "RUN_MODULE_IMG"))
        return RUN_MODULE_IMG;
    else if (0 == strcmp(strEnum.c_str(), "RUN_MODULE_UNIT"))
        return RUN_MODULE_UNIT;
    else if (0 == strcmp(strEnum.c_str(), "RUN_MODULE_DEFAULT"))
        return RUN_MODULE_DEFAULT;
    else {
        LOG_ERROR("Input RUN_MODULE strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(RUN_MODULE enumInput) {
    if (RUN_MODULE_INVALID == enumInput)
        return "RUN_MODULE_INVALID";
    else if (RUN_MODULE_MP4 == enumInput)
        return "RUN_MODULE_MP4";
    else if (RUN_MODULE_IMG == enumInput)
        return "RUN_MODULE_IMG";
    else if (RUN_MODULE_UNIT == enumInput)
        return "RUN_MODULE_UNIT";
    else if (RUN_MODULE_DEFAULT == enumInput)
        return "RUN_MODULE_DEFAULT";
    else {
        LOG_ERROR("Input RUN_MODULE enum Error!\n");
        exit(1);
    }
}
//////////////////////////////////////////////////////
////                   sdk enum
//////////////////////////////////////////////////////
/*1 ASD_EVENT_TYPE*/
ASD_EVENT_TYPE EnumCvt::String2Enum_ASD_EVENT_TYPE(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "ASD_EVENT_DMS"))
    return ASD_EVENT_DMS;
    else if (0 == strcmp(strEnum.c_str(), "ASD_EVENT_OMS"))
        return ASD_EVENT_OMS;
    else if (0 == strcmp(strEnum.c_str(), "ASD_EVENT_MAX"))
        return ASD_EVENT_MAX;
    else {
        LOG_ERROR("Input ASD_EVENT_strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(ASD_EVENT_TYPE enumInput) {
    if (ASD_EVENT_DMS == enumInput)
        return "ASD_EVENT_DMS";
    else if (ASD_EVENT_OMS == enumInput)
        return "ASD_EVENT_OMS";
    else if (ASD_EVENT_MAX == enumInput)
        return "ASD_EVENT_MAX";
    else {
        LOG_ERROR("Input SDK_MODULE_enum Error!\n");
        exit(1);
    }
}
/*2 ASD_ALARM_TYPE*/
ASD_ALARM_TYPE EnumCvt::String2Enum_ASD_ALARM_TYPE(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "ASD_ALARM_TYPE_NONE"))
    return ASD_ALARM_TYPE_NONE;
    else if (0 == strcmp(strEnum.c_str(), "ASD_ALARM_TYPE_DISTRACT"))
        return ASD_ALARM_TYPE_DISTRACT;
    else if (0 == strcmp(strEnum.c_str(), "ASD_ALARM_TYPE_DROWSY"))
        return ASD_ALARM_TYPE_DROWSY;
     else if (0 == strcmp(strEnum.c_str(), "ASD_ALARM_TYPE_DANGER_ACTION"))
        return ASD_ALARM_TYPE_DANGER_ACTION;
     else if (0 == strcmp(strEnum.c_str(), "ASD_ALARM_TYPE_EXPRESSION"))
        return ASD_ALARM_TYPE_EXPRESSION;
     else {
        LOG_ERROR("Input ASD_ALARM_TYPE_strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(ASD_ALARM_TYPE enumInput) {
    if (ASD_ALARM_TYPE_NONE == enumInput)
        return "ASD_ALARM_TYPE_NONE";
    else if (ASD_ALARM_TYPE_DISTRACT == enumInput)
        return "ASD_ALARM_TYPE_DISTRACT";
    else if (ASD_ALARM_TYPE_DROWSY == enumInput)
        return "ASD_ALARM_TYPE_DROWSY";
    else if (ASD_ALARM_TYPE_DANGER_ACTION == enumInput)
        return "ASD_ALARM_TYPE_DANGER_ACTION";
    else if (ASD_ALARM_TYPE_EXPRESSION == enumInput)
        return "ASD_ALARM_TYPE_EXPRESSION";
    else {
        LOG_ERROR("Input ASD_ALARM_TYPE_enum Error!\n");
        exit(1);
    }
}
/*3 ASD_DISTRACT_LEVEL*/
ASD_DISTRACT_LEVEL EnumCvt::String2Enum_ASD_DISTRACT_LEVEL(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "ASD_DISTRACT_LEVEL_INVALID"))
    return ASD_DISTRACT_LEVEL_INVALID;
    else if (0 == strcmp(strEnum.c_str(), "ASD_DISTRACT_LEVEL_NONE"))
        return ASD_DISTRACT_LEVEL_NONE;
    else if (0 == strcmp(strEnum.c_str(), "ASD_DISTRACT_LEVEL_LOW"))
        return ASD_DISTRACT_LEVEL_LOW;
    else if (0 == strcmp(strEnum.c_str(), "ASD_DISTRACT_LEVEL_MIDDLE"))
        return ASD_DISTRACT_LEVEL_MIDDLE;
    else if (0 == strcmp(strEnum.c_str(), "ASD_DISTRACT_LEVEL_HIGH"))
        return ASD_DISTRACT_LEVEL_HIGH;
    else {
        LOG_ERROR("Input ASD_DISTRACT_LEVEL_strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(ASD_DISTRACT_LEVEL enumInput) {
    if (ASD_DISTRACT_LEVEL_INVALID == enumInput)
        return "ASD_DISTRACT_LEVEL_INVALID";
    else if (ASD_DISTRACT_LEVEL_NONE == enumInput)
        return "ASD_DISTRACT_LEVEL_NONE";
    else if (ASD_DISTRACT_LEVEL_LOW == enumInput)
        return "ASD_DISTRACT_LEVEL_LOW";
    else if (ASD_DISTRACT_LEVEL_MIDDLE == enumInput)
        return "ASD_DISTRACT_LEVEL_MIDDLE";
    else if (ASD_DISTRACT_LEVEL_HIGH == enumInput)
        return "ASD_DISTRACT_LEVEL_HIGH";
    else {
        LOG_ERROR("Input ASD_DISTRACT_enum Error!\n");
        exit(1);
    }
}
/*4 ASD_DROWSY_LEVEL*/
ASD_DROWSY_LEVEL EnumCvt::String2Enum_ASD_DROWSY_LEVEL(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "ASD_DROWSY_LEVEL_INVALID"))
    return ASD_DROWSY_LEVEL_INVALID;
    else if (0 == strcmp(strEnum.c_str(), "ASD_DROWSY_LEVEL_NONE"))
        return ASD_DROWSY_LEVEL_NONE;
    else if (0 == strcmp(strEnum.c_str(), "ASD_DROWSY_LEVEL_LOW"))
        return ASD_DROWSY_LEVEL_LOW;
    else if (0 == strcmp(strEnum.c_str(), "ASD_DROWSY_LEVEL_MIDDLE"))
        return ASD_DROWSY_LEVEL_MIDDLE;
    else if (0 == strcmp(strEnum.c_str(), "ASD_DROWSY_LEVEL_HIGH"))
        return ASD_DROWSY_LEVEL_HIGH;
    else {
        LOG_ERROR("Input ASD_DROWSY_LEVEL_strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(ASD_DROWSY_LEVEL enumInput) {
    if (ASD_DROWSY_LEVEL_INVALID == enumInput)
        return "ASD_DROWSY_LEVEL_INVALID";
    else if (ASD_DROWSY_LEVEL_NONE == enumInput)
        return "ASD_DROWSY_LEVEL_NONE";
    else if (ASD_DROWSY_LEVEL_LOW == enumInput)
        return "ASD_DROWSY_LEVEL_LOW";
    else if (ASD_DROWSY_LEVEL_MIDDLE == enumInput)
        return "ASD_DROWSY_LEVEL_MIDDLE";
    else if (ASD_DROWSY_LEVEL_HIGH == enumInput)
        return "ASD_DROWSY_LEVEL_HIGH";
    else {
        LOG_ERROR("Input ASD_DROWSY_LEVEL_enum Error!\n");
        exit(1);
    }
}
/*5 ASD_DANGER_ACTION*/
ASD_DANGER_ACTION EnumCvt::String2Enum_ASD_DANGER_ACTION(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "ASD_DANGER_ACTION_INVALID"))
    return ASD_DANGER_ACTION_INVALID;
    else if (0 == strcmp(strEnum.c_str(), "ASD_DANGER_ACTION_SMOKE"))
        return ASD_DANGER_ACTION_SMOKE;
    else if (0 == strcmp(strEnum.c_str(), "ASD_DANGER_ACTION_CALL"))
        return ASD_DANGER_ACTION_CALL;
        else if (0 == strcmp(strEnum.c_str(), "ASD_DANGER_ACTION_NONE"))
        return ASD_DANGER_ACTION_NONE;
    else {
        LOG_ERROR("Input ASD_DANGER_ACTION_strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(ASD_DANGER_ACTION enumInput) {
    if (ASD_DANGER_ACTION_INVALID == enumInput)
        return "ASD_DANGER_ACTION_INVALID";
    else if (ASD_DANGER_ACTION_SMOKE == enumInput)
        return "ASD_DANGER_ACTION_SMOKE";
    else if (ASD_DANGER_ACTION_CALL == enumInput)
        return "ASD_DANGER_ACTION_CALL";
    else if (ASD_DANGER_ACTION_NONE == enumInput)
        return "ASD_DANGER_ACTION_NONE";
    else {
        LOG_ERROR("Input ASD_DANGER_enum Error!\n");
        exit(1);
    }
}
/*6 ASD_ACTION_TYPE*/
ASD_ACTION_TYPE EnumCvt::String2Enum_ASD_ACTION_TYPE(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "ASD_ACTION_TYPE_NONE"))
    return ASD_ACTION_TYPE_NONE;
    else if (0 == strcmp(strEnum.c_str(), "ASD_ACTION_TYPE_NOD"))
        return ASD_ACTION_TYPE_NOD;
    else if (0 == strcmp(strEnum.c_str(), "ASD_ACTION_TYPE_SHAKE"))
        return ASD_ACTION_TYPE_SHAKE;
    else {
        LOG_ERROR("Input ASD_ACTION_TYPE_strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(ASD_ACTION_TYPE enumInput) {
if (ASD_ACTION_TYPE_NONE == enumInput)
    return "ASD_ACTION_TYPE_NONE";
else if (ASD_ACTION_TYPE_NOD == enumInput)
    return "ASD_ACTION_TYPE_NOD";
else if (ASD_ACTION_TYPE_SHAKE == enumInput)
    return "ASD_ACTION_TYPE_SHAKE";
else {
    LOG_ERROR("Input ASD_ACTION_TYPE_enum Error!\n");
    exit(1);
}
}
/*7 ASD_EXPRESSION_TYPE*/
ASD_EXPRESSION_TYPE EnumCvt::String2Enum_ASD_EXPRESSION_TYPE(const std::string& strEnum) {
if (0 == strcmp(strEnum.c_str(), "ASD_EXPRESSION_TYPE_INVALID"))
return ASD_EXPRESSION_TYPE_INVALID;
else if (0 == strcmp(strEnum.c_str(), "ASD_EXPRESSION_TYPE_HAPPY"))
    return ASD_EXPRESSION_TYPE_HAPPY;
else if (0 == strcmp(strEnum.c_str(), "ASD_EXPRESSION_TYPE_ANGRY"))
    return ASD_EXPRESSION_TYPE_ANGRY;
else if (0 == strcmp(strEnum.c_str(), "ASD_EXPRESSION_TYPE_SAD"))
    return ASD_EXPRESSION_TYPE_SAD;
else if (0 == strcmp(strEnum.c_str(), "ASD_EXPRESSION_TYPE_NORMAL"))
    return ASD_EXPRESSION_TYPE_NORMAL;
else {
    LOG_ERROR("Input ASD_EXPRESSION_TYPE_strEnum Error!\n");
    //return 5;
    //exit(1);
}
}

std::string EnumCvt::Enum2String(ASD_EXPRESSION_TYPE enumInput) {
if (ASD_EXPRESSION_TYPE_INVALID == enumInput)
    return "ASD_EXPRESSION_TYPE_INVALID";
else if (ASD_EXPRESSION_TYPE_HAPPY == enumInput)
    return "ASD_EXPRESSION_TYPE_HAPPY";
else if (ASD_EXPRESSION_TYPE_ANGRY == enumInput)
    return "ASD_EXPRESSION_TYPE_ANGRY";
else if (ASD_EXPRESSION_TYPE_SAD == enumInput)
    return "ASD_EXPRESSION_TYPE_SAD";
else if (ASD_EXPRESSION_TYPE_NORMAL == enumInput)
    return "ASD_EXPRESSION_TYPE_NORMAL";
else { 
    LOG_ERROR("Input ASD_EXPRESSION_TYPE_enum Error!\n");
    return "ASD_EXPRESSION_TYPE_OTHER";
    //exit(1);
}
}
/*8 ASD_GAZE_AREA*/
ASD_GAZE_AREA EnumCvt::String2Enum_ASD_GAZE_AREA(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "ASD_GAZE_AREA_INVALID"))
    return ASD_GAZE_AREA_INVALID;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GAZE_AREA_MAIN_DRIVING_WINDSCREEN"))
        return ASD_GAZE_AREA_MAIN_DRIVING_WINDSCREEN;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GAZE_AREA_CENTER_CONSOLE"))
        return ASD_GAZE_AREA_CENTER_CONSOLE;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GAZE_AREA_MAIN_DRIVING_SCREEN"))
        return ASD_GAZE_AREA_MAIN_DRIVING_SCREEN;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GAZE_AREA_LEFT_REARVIEW"))
        return ASD_GAZE_AREA_LEFT_REARVIEW;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GAZE_AREA_RIGHT_REARVIEW"))
        return ASD_GAZE_AREA_RIGHT_REARVIEW;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GAZE_AREA_OTHER"))
        return ASD_GAZE_AREA_OTHER;
    else {
        LOG_ERROR("Input _strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(ASD_GAZE_AREA enumInput) {
    if (ASD_GAZE_AREA_INVALID == enumInput)
        return "ASD_GAZE_AREA_INVALID";
    else if (ASD_GAZE_AREA_MAIN_DRIVING_WINDSCREEN == enumInput)
        return "ASD_GAZE_AREA_MAIN_DRIVING_WINDSCREEN";
    else if (ASD_GAZE_AREA_CENTER_CONSOLE == enumInput)
        return "ASD_GAZE_AREA_CENTER_CONSOLE";
    else if (ASD_GAZE_AREA_MAIN_DRIVING_SCREEN == enumInput)
        return "ASD_GAZE_AREA_MAIN_DRIVING_SCREEN";
    else if (ASD_GAZE_AREA_LEFT_REARVIEW == enumInput)
        return "ASD_GAZE_AREA_LEFT_REARVIEW";
    else if (ASD_GAZE_AREA_RIGHT_REARVIEW == enumInput)
        return "ASD_GAZE_AREA_RIGHT_REARVIEW";
    else if (ASD_GAZE_AREA_OTHER == enumInput)
        return "ASD_GAZE_AREA_OTHER";
    else {
        LOG_ERROR("Input ASD_GAZE_AREA_enum Error!\n");
        exit(1);
    }
}
/*9 ASD_GESTURE_TYPE*/
ASD_GESTURE_TYPE EnumCvt::String2Enum_ASD_GESTURE_TYPE(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "ASD_GESTURE_TYPE_INVALID"))
    return ASD_GESTURE_TYPE_INVALID;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GESTURE_TYPE_MUTE"))
        return ASD_GESTURE_TYPE_MUTE;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GESTURE_TYPE_VSIGN"))
        return ASD_GESTURE_TYPE_VSIGN;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GESTURE_TYPE_OK"))
        return ASD_GESTURE_TYPE_OK;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GESTURE_TYPE_THUMBUP"))
        return ASD_GESTURE_TYPE_THUMBUP;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GESTURE_TYPE_CIRCLE_CW"))
        return ASD_GESTURE_TYPE_CIRCLE_CW;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GESTURE_TYPE_CIRCLE_CCW"))
        return ASD_GESTURE_TYPE_CIRCLE_CCW;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GESTURE_TYPE_SWIPE_LEFT"))
        return ASD_GESTURE_TYPE_SWIPE_LEFT;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GESTURE_TYPE_SWIPE_RIGHT"))
        return ASD_GESTURE_TYPE_SWIPE_RIGHT;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GESTURE_TYPE_SWIPE_FORWARD"))
        return ASD_GESTURE_TYPE_SWIPE_FORWARD;
    else if (0 == strcmp(strEnum.c_str(), "ASD_GESTURE_TYPE_SWIPE_BACKWARD"))
        return ASD_GESTURE_TYPE_SWIPE_BACKWARD;
    else {
        LOG_ERROR("Input ASD_GESTURE_TYPE_strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(ASD_GESTURE_TYPE enumInput) {
    if (ASD_GESTURE_TYPE_INVALID == enumInput)
        return "ASD_GESTURE_TYPE_INVALID";
    else if (ASD_GESTURE_TYPE_MUTE == enumInput)
        return "ASD_GESTURE_TYPE_MUTE";
        else if (ASD_GESTURE_TYPE_VSIGN == enumInput)
        return "ASD_GESTURE_TYPE_VSIGN";
    else if (ASD_GESTURE_TYPE_OK == enumInput)
        return "ASD_GESTURE_TYPE_OK";
    else if (ASD_GESTURE_TYPE_THUMBUP == enumInput)
        return "ASD_GESTURE_TYPE_THUMBUP";
    else if (ASD_GESTURE_TYPE_CIRCLE_CW == enumInput)
        return "ASD_GESTURE_TYPE_CIRCLE_CW";
    else if (ASD_GESTURE_TYPE_CIRCLE_CCW == enumInput)
        return "ASD_GESTURE_TYPE_CIRCLE_CCW";

    else if (ASD_GESTURE_TYPE_SWIPE_LEFT == enumInput)
        return "ASD_GESTURE_TYPE_SWIPE_LEFT";
    else if (ASD_GESTURE_TYPE_SWIPE_RIGHT == enumInput)
        return "ASD_GESTURE_TYPE_SWIPE_RIGHT";
    else if (ASD_GESTURE_TYPE_SWIPE_FORWARD == enumInput)
        return "ASD_GESTURE_TYPE_SWIPE_FORWARD";
    else if (ASD_GESTURE_TYPE_SWIPE_BACKWARD == enumInput)
        return "ASD_GESTURE_TYPE_SWIPE_BACKWARD";
    else {
        LOG_ERROR("Input ASD_GESTURE_TYPE_enum Error!\n");
        exit(1);
    }
}   
/*10 ASD_BABY_TYPE*/
ASD_BABY_TYPE EnumCvt::String2Enum_ASD_BABY_TYPE(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "ASD_BABY_TYPE_INVALID"))
    return ASD_BABY_TYPE_INVALID;
    else if (0 == strcmp(strEnum.c_str(), "ASD_BABY_TYPE_IN_SAFETYSEAT"))
        return ASD_BABY_TYPE_IN_SAFETYSEAT;
    else if (0 == strcmp(strEnum.c_str(), "ASD_BABY_TYPE_OUT_SAFETYSEAT"))
        return ASD_BABY_TYPE_OUT_SAFETYSEAT;
    else if (0 == strcmp(strEnum.c_str(), "ASD_BABY_TYPE_OTHER"))
        return ASD_BABY_TYPE_OTHER;
    else {
        LOG_ERROR("Input ASD_BABY_TYPE_strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(ASD_BABY_TYPE enumInput) {
    if (ASD_BABY_TYPE_INVALID == enumInput)
        return "ASD_BABY_TYPE_INVALID";
    else if (ASD_BABY_TYPE_IN_SAFETYSEAT == enumInput)
        return "ASD_BABY_TYPE_IN_SAFETYSEAT";
    else if (ASD_BABY_TYPE_OUT_SAFETYSEAT == enumInput)
        return "ASD_BABY_TYPE_OUT_SAFETYSEAT";
    else if (ASD_BABY_TYPE_OTHER == enumInput)
        return "ASD_BABY_TYPE_OTHER";
    else {
        LOG_ERROR("Input ASD_BABY_TYPE_enum Error!\n");
        exit(1);
    }
}
/*11 ASD_SEAT_ID*/
ASD_SEAT_ID EnumCvt::String2Enum_ASD_SEAT_ID(const std::string& strEnum) {
    if (0 == strcmp(strEnum.c_str(), "ASD_SEAT_ID_UNKNOWN"))
    return ASD_SEAT_ID_UNKNOWN;
    else if (0 == strcmp(strEnum.c_str(), "ASD_SEAT_ID_CO_DRIVER"))
        return ASD_SEAT_ID_CO_DRIVER;
    else if (0 == strcmp(strEnum.c_str(), "ASD_SEAT_ID_REAR_LEFT"))
        return ASD_SEAT_ID_REAR_LEFT;
    else if (0 == strcmp(strEnum.c_str(), "ASD_SEAT_ID_REAR_MID"))
        return ASD_SEAT_ID_REAR_MID;
    else if (0 == strcmp(strEnum.c_str(), "ASD_SEAT_ID_REAR_RIGHT"))
        return ASD_SEAT_ID_REAR_RIGHT;
    else if (0 == strcmp(strEnum.c_str(), "ASD_SEAT_ID_DRIVER"))
        return ASD_SEAT_ID_DRIVER;
    else {
        LOG_ERROR("Input ASD_SEAT_ID_strEnum Error!\n");
        exit(1);
    }
}
std::string EnumCvt::Enum2String(ASD_SEAT_ID enumInput) {
    if (ASD_SEAT_ID_UNKNOWN == enumInput)
        return "ASD_SEAT_ID_UNKNOWN";
    else if (ASD_SEAT_ID_CO_DRIVER == enumInput)
        return "ASD_SEAT_ID_CO_DRIVER";
    else if (ASD_SEAT_ID_REAR_LEFT == enumInput)
        return "ASD_SEAT_ID_REAR_LEFT";
    else if (ASD_SEAT_ID_REAR_MID == enumInput)
        return "ASD_SEAT_ID_REAR_MID";
    else if (ASD_SEAT_ID_REAR_RIGHT == enumInput)
        return "ASD_SEAT_ID_REAR_RIGHT";
    else if (ASD_SEAT_ID_DRIVER == enumInput)
        return "ASD_SEAT_ID_DRIVER";
    else {
        LOG_ERROR("Input ASD_SEAT_ID_enum Error!\n");
        exit(1);
    }
}
/*12 ASD_PASSENGER_GENDER*/
ASD_PASSENGER_GENDER EnumCvt::String2Enum_ASD_PASSENGER_GENDER(const std::string& strEnum){
    if (0 == strcmp(strEnum.c_str(), "ASD_PASSENGER_GENDER_UNKNOWN"))
    return ASD_PASSENGER_GENDER_UNKNOWN;
    else if (0 == strcmp(strEnum.c_str(), "ASD_PASSENGER_GENDER_MALE"))
        return ASD_PASSENGER_GENDER_MALE;
    else if (0 == strcmp(strEnum.c_str(), "ASD_PASSENGER_GENDER_FEMALE"))
        return ASD_PASSENGER_GENDER_FEMALE;
    else {
        LOG_ERROR("Input ASD_PASSENGER_GENDER_strEnum Error!\n");
        exit(1);
    }
}

std::string EnumCvt::Enum2String(ASD_PASSENGER_GENDER enumInput) {
    if (ASD_PASSENGER_GENDER_UNKNOWN == enumInput)
        return "ASD_PASSENGER_GENDER_UNKNOWN";
    else if (ASD_PASSENGER_GENDER_MALE == enumInput)
        return "ASD_PASSENGER_GENDER_MALE";
    else if (ASD_PASSENGER_GENDER_FEMALE == enumInput)
        return "ASD_PASSENGER_GENDER_FEMALE";
    else {
        LOG_ERROR("Input ASD_PASSENGER_GENDER_enum Error!\n");
        exit(1);
    }
}

/*13 ASD_SEAT_ID*/
// ASD_SEAT_ID EnumCvt::String2Enum_ASD_SEAT_ID(const std::string& strEnum) {
//      if (0 == strcmp(strEnum.c_str(), "ASD_SEAT_ID_UNKNOWN"))
//         return ASD_SEAT_ID_UNKNOWN;
//     else if (0 == strcmp(strEnum.c_str(), "ASD_SEAT_ID_CO_DRIVER"))
//         return ASD_SEAT_ID_CO_DRIVER;
//     else if (0 == strcmp(strEnum.c_str(), "ASD_SEAT_ID_REAR_LEFT"))
//          return ASD_SEAT_ID_REAR_LEFT;
//      else if (0 == strcmp(strEnum.c_str(), "ASD_SEAT_ID_REAR_MID"))
//          return ASD_SEAT_ID_REAR_MID;
//      else if (0 == strcmp(strEnum.c_str(), "ASD_SEAT_ID_REAR_RIGHT"))
//          return ASD_SEAT_ID_REAR_RIGHT;
//      else if (0 == strcmp(strEnum.c_str(), "ASD_SEAT_ID_DRIVER"))
//         return ASD_SEAT_ID_DRIVER;
//      else {
//         LOG_ERROR("Input ASD_SEAT_ID strEnum Error!\n");
//         exit(1);
//     }
// }
// std::string EnumCvt::Enum2String(ASD_SEAT_ID enumInput) {
//     if (ASD_SEAT_ID_UNKNOWN == enumInput)
//         return "ASD_SEAT_ID_UNKNOWN";
//     else if (ASD_SEAT_ID_CO_DRIVER == enumInput)
//         return "ASD_SEAT_ID_CO_DRIVER";
//     else if (ASD_SEAT_ID_REAR_LEFT == enumInput)
//         return "ASD_SEAT_ID_REAR_LEFT";
//     else if (ASD_SEAT_ID_REAR_MID == enumInput)
//         return "ASD_SEAT_ID_REAR_MID";
//     else if (ASD_SEAT_ID_REAR_RIGHT == enumInput)
//         return "ASD_SEAT_ID_REAR_RIGHT";
//     else if (ASD_SEAT_ID_DRIVER == enumInput)
//         return "ASD_SEAT_ID_DRIVER";
//     else {
//         LOG_ERROR("Input ASD_SEAT_ID enum Error!\n");
//         exit(1);
//     }
// }



/////////////////////////////////////////////////////////////////////////////////////////////////////////////
////                   SetGSync
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
SetGSync::SetGSync() {}
SetGSync::~SetGSync() {
    pG_SyncInfo = NULL;
    //LOG_DEBUG("uinit SetGSync, pG_SyncInfo be NULL!\n");
}
SetGSync::SetGSync(G_SyncInfo& g_SyncInfo) {
    pG_SyncInfo = &g_SyncInfo;
    EnumCvt enumCvt;
    //LOG_DEBUG("init SetGSync, SDK_MODULE:%s, SYNC_TYPE:%s\n", enumCvt.Enum2String(pG_SyncInfo->enumSdkModule).c_str(), enumCvt.Enum2String(pG_SyncInfo->enumSyncType).c_str());
}
void SetGSync::Reset(SDK_MODULE enumSdkModule, SYNC_TYPE enumSyncType) {
    EnumCvt enumCvt;
    pG_SyncInfo->enumRunModule = RUN_MODULE_DEFAULT;
    pG_SyncInfo->enumSdkModule = enumSdkModule;
    pG_SyncInfo->enumSyncType = enumSyncType;
    //LOG_DEBUG("reset GSync, SDK_MODULE:%s, SYNC_TYPE:%s\n", enumCvt.Enum2String(pG_SyncInfo->enumSdkModule).c_str(), enumCvt.Enum2String(pG_SyncInfo->enumSyncType).c_str());
}
void SetGSync::Set(G_SyncMp4& l_SycnMp4) {
    EnumCvt enumCvt;
    pG_SyncInfo->g_SyncMp4 = l_SycnMp4;
    pG_SyncInfo->enumRunModule = RUN_MODULE_MP4;
    //LOG_DEBUG("set Mp4_GSync, SDK_MODULE:%s\n", enumCvt.Enum2String(pG_SyncInfo->enumSdkModule).c_str());
}
void SetGSync::Set(G_SyncImg& l_SycnImg) {
    EnumCvt enumCvt;
    pG_SyncInfo->g_SyncImg = l_SycnImg;
    pG_SyncInfo->enumRunModule = RUN_MODULE_IMG;
    //LOG_DEBUG("set Img_GSync, SDK_MODULE:%s\n", enumCvt.Enum2String(pG_SyncInfo->enumSdkModule).c_str());
}
void SetGSync::Set(G_SyncUnit& l_SycnUnit) {
    EnumCvt enumCvt;
    pG_SyncInfo->g_SyncUnit = l_SycnUnit;
    pG_SyncInfo->enumRunModule = RUN_MODULE_UNIT;
    //LOG_DEBUG("set Unit_GSync, SDK_MODULE:%s\n", enumCvt.Enum2String(pG_SyncInfo->enumSdkModule).c_str());
}
void SetGSync::InitAll(G_SyncInfo& Main2Putdata_DMS,G_SyncInfo& Main2Putdata_OOMS,G_SyncInfo& Putdata2Callback_DMS, G_SyncInfo& Putdata2Callback_OOMS){
    EnumCvt enumCvt;
    Main2Putdata_DMS.enumRunModule = RUN_MODULE_DEFAULT;
    Main2Putdata_DMS.enumSdkModule = SDK_MODULE_DMS;
    Main2Putdata_DMS.enumSyncType = SYNC_TYPE_MAIN_TO_DATAPUT;
    //LOG_DEBUG("reset GSync, SDK_MODULE:%s, SYNC_TYPE:%s\n", enumCvt.Enum2String(Main2Putdata_DMS.enumSdkModule).c_str(), enumCvt.Enum2String(Main2Putdata_DMS.enumSyncType).c_str());

    Main2Putdata_OOMS.enumRunModule = RUN_MODULE_DEFAULT;
    Main2Putdata_OOMS.enumSdkModule = SDK_MODULE_OMS;
    Main2Putdata_OOMS.enumSyncType = SYNC_TYPE_MAIN_TO_DATAPUT;
    //LOG_DEBUG("reset GSync, SDK_MODULE:%s, SYNC_TYPE:%s\n", enumCvt.Enum2String(Main2Putdata_OOMS.enumSdkModule).c_str(), enumCvt.Enum2String(Main2Putdata_OOMS.enumSyncType).c_str());

    Putdata2Callback_DMS.enumRunModule = RUN_MODULE_DEFAULT;
    Putdata2Callback_DMS.enumSdkModule = SDK_MODULE_DMS;
    Putdata2Callback_DMS.enumSyncType = SYNC_TYPE_DATAPUT_TO_CALLBACK;
    //LOG_DEBUG("reset GSync, SDK_MODULE:%s, SYNC_TYPE:%s\n", enumCvt.Enum2String(Putdata2Callback_DMS.enumSdkModule).c_str(), enumCvt.Enum2String(Putdata2Callback_DMS.enumSyncType).c_str());

    Putdata2Callback_OOMS.enumRunModule = RUN_MODULE_DEFAULT;
    Putdata2Callback_OOMS.enumSdkModule = SDK_MODULE_OMS;
    Putdata2Callback_OOMS.enumSyncType = SYNC_TYPE_DATAPUT_TO_CALLBACK;
    //LOG_DEBUG("reset GSync, SDK_MODULE:%s, SYNC_TYPE:%s\n", enumCvt.Enum2String(Putdata2Callback_OOMS.enumSdkModule).c_str(), enumCvt.Enum2String(Putdata2Callback_OOMS.enumSyncType).c_str());
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
////                   SourceAdapt
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //source adapt
// bool SourceAdapt::IsDir(const std::string& pathInput){
//     struct stat statBuf;
//     stat(pathInput.c_str(), &statBuf);
//     if (S_ISDIR(statBuf.st_mode))
//         return true;
//     else
//         return false;
// }
// void SourceAdapt::VecFileter(std::vector<std::string>& vecInput, std::vector<std::string>& vecOutput, const std::string& strfield) {
//     int countSuccess = 0;
//     for (std::string temStr : vecInput) {
//         if (temStr.find(strfield.c_str()) != std::string::npos) {
//             vecOutput.push_back(temStr);
//             countSuccess++;
//         }
//     }
// }
// std::string SourceAdapt::GetCurrentDir(std::string pathInFile, std::string strSeparator) {
//     //need judge get path if dir
//     if(pathInFile.rfind(strSeparator.c_str()) == std::string::npos){
//         LOG_ERROR("can't find [%s], in path:%s\n", strSeparator.c_str(), pathInFile.c_str());
//         exit(1);
//     }
//     std::string pathDir = pathInFile.substr(0, pathInFile.rfind(strSeparator.c_str()));
//     return pathDir;
// }
// bool SourceAdapt::JudgeFileExist(const std::string& strInPath) {
//     FILE* pFile = NULL;
//     pFile = fopen(strInPath.c_str(), "r");
//     if (NULL == pFile) {
//           fclose(pFile);
//           return false;
//     }
//     else {
//           fclose(pFile);
//           return true;
//     }
// }
// void SourceAdapt::PushOneSource(std::string pathFunctionTxt) {
//     int sourceCounter = 0;
//     //get sdkCfg
//     UnitSdkCfg tempUnitSdkCfg;
//     Source tempSource;
//     ReadSdkCfg(pathFunctionTxt, tempUnitSdkCfg);
//     tempSource.unitSdkCfg = tempUnitSdkCfg;
//     tempSource.pathFunctionTxt = pathFunctionTxt;
//     //get current dir
//     std::string strCurrentDir = GetCurrentDir(pathFunctionTxt, "/");
//     tempSource.pathCurrentDir = strCurrentDir;
//     //get video 
//     std::string strVideoPath;
//     std::vector<std::string> tempVecMp4;
//     GetFileListRecursion(strCurrentDir, tempVecMp4, { ".mp4" });
//     if (1 != tempVecMp4.size()) {//if tempVecMp4 size() == 0
//         LOG_ERROR("can't search mp4 file from dir_path:%s\n", strCurrentDir.c_str());
//         //exit(1);
//     }
//     else {
//         strVideoPath = tempVecMp4[0];
//         tempSource.pathVideo = strVideoPath;
//         sourceCounter++;
//         LOG_INFO("find the mp4:%s, by currentDir:%s\n", strVideoPath.c_str(), strCurrentDir.c_str());
//     }
//     //get unit 
//     std::string strUnitPath;
//     std::vector<std::string> tempVecImg;
//     GetFileListRecursion(strCurrentDir, tempVecImg, { ".jpg" });
//     if (0 >= tempVecImg.size()) {//if tempVecMp4 size() == 0
//         LOG_ERROR("warning! can't search jpg file from dir_path:%s\n", strCurrentDir.c_str());
//         //exit(1);
//     }
//     else {
//         strUnitPath = GetCurrentDir(tempVecImg[0], "/");
//         tempSource.pathUnit = strUnitPath;
//         sourceCounter++;
//         LOG_INFO("find the unitPath:%s, by currentDir:%s\n", strUnitPath.c_str(), strCurrentDir.c_str());
//     }

//     if (sourceCounter < 1) {
//         LOG_ERROR("can't find mp4 or unit, by currentDir:%s\n", strCurrentDir.c_str());
//         exit(1);
//     }else {
//         LOG_INFO("push source finish!\n");
//         vecSource.push_back(tempSource);
//     }
// }
// void SourceAdapt::ReadTxt(const std::string& pathTxt, std::string& strOut, bool isOneLine) {
//     std::ifstream inStmTxt(pathTxt);
//     std::string tempStr;
//     if(true == isOneLine){
//         while (std::getline(inStmTxt, tempStr)) {
//             strOut = tempStr;
//             break;
//         }
//     } 
//     else{
//         while (std::getline(inStmTxt, tempStr)){
//             strOut = strOut + tempStr;
//         }
//     }
//     inStmTxt.close();
// }
// void SourceAdapt::ReadSdkCfg(std::string pathFunctionTxt, UnitSdkCfg& unitSdkCfg) {
//     //field: sdk_module_type, sdk_function_type, process_enable
//     //field(cfg):set_param_key_array,set_param_value_array,perframe_time_us,pervideo_process_time_s,frame_number,
//     //read functionTxt => get enumFunctoin ==> read cfgTxt ===> Cvt to cfgStruct
//     EnumCvt enumCvt;
//     //read functionTxt
//     std::string strFunction;
//     if (false == JudgeFileExist(pathFunctionTxt)) {
//         LOG_ERROR("can't open file:%s\n", pathFunctionTxt.c_str());
//         exit(1);
//     }
//     ReadTxt(pathFunctionTxt, strFunction, true);
//     if(strFunction.size()<3){
//         LOG_ERROR("read functionTxt error! strFunction.size() = %d\n", strFunction.size());
//         exit(1);
//     }
//     //read cfgTxt
//     std::string strSdkCfg;
//     if (false == JudgeFileExist("./"+strSdkCfgTxtName)) {
//         LOG_ERROR("can't open file:%s\n", ("./"+strSdkCfgTxtName).c_str());
//         exit(1);
//     }
//     ReadTxt(("./"+strSdkCfgTxtName), strSdkCfg, true);
//     if(strSdkCfg.size()<3){
//         LOG_ERROR("read strSdkCfgTxt error! strSdkCfg.size() = %d, path:%s\n", strSdkCfg.size(), ("./" + strSdkCfgTxtName).c_str());
//         exit(1);
//     }
//     //judge functionTxt content
//     json jsReadFunction;
//     jsReadFunction = json::parse(strFunction);
//     //LOG_DEBUG("jsReadFunction:%s\n", jsReadFunction.dump(4).c_str());
//     if (0 != jsReadFunction.empty()) {
//         LOG_ERROR("parse strFunction error!, strFunction:%s\n", strFunction.c_str());
//         exit(1);
//     }
//     //judge cfgTxt content
//     json jsReadSdkCfg;
//     jsReadSdkCfg = json::parse(strSdkCfg);
//     //LOG_DEBUG("jsReadSdkCfg:%s\n", jsReadSdkCfg.dump(4).c_str());
//     if (0 != jsReadSdkCfg.empty()) {
//         LOG_ERROR("parse strSdkCfg error!, strSdkCfg:%s\n", strSdkCfg.c_str());
//         exit(1);
//     }

//     //parse cfgItem
//     json jsCfgItem;
//     std::string strSdkFunctioinType = jsReadFunction["sdk_function_type"];
//     //LOG_DEBUG("strSdkFunctioinType:%s\n", strSdkFunctioinType.c_str());
//     jsCfgItem = jsReadSdkCfg[strSdkFunctioinType];
//     //LOG_DEBUG("jsCfgItem:%s\n", jsCfgItem.dump(4).c_str());
//     //set param array
//     if (jsCfgItem["set_param_key_array"].size() == 0) {
//         //LOG_ERROR("warning! set_param_key_array.size() == 0,cfgPath:%s\n", ("./" + strSdkCfgTxtName));
//     }
//     else {
//         // for (std::string strItem : jsCfgItem["set_param_key_array"]) {
//         //     unitSource.unitSdkCfg.vecParamKey.push_back(static_cast<ARC_ALG_PARAM_TYPE>(std::stoi(strItem.c_str())));
//         //  }
//     }
//     if (jsCfgItem["set_param_value_array"].size() == 0) {
//         //LOG_ERROR("warning! set_param_value_array.size() == 0,cfgPath:%s\n", ("./" + strSdkCfgTxtName));
//     }else{
//         // for (std::string strItem : jsCfgItem["set_param_value_array"]) {
//         //     unitSource.unitSdkCfg.vecParamValue.push_back(static_cast<ARC_ALG_PARAM_TYPE>(std::stoi(strItem.c_str())));
//         // }
//     }
//     //set play param 
//     unitSdkCfg.perFrameTimeUs = std::stoi(jsCfgItem["perframe_time_us"].get<std::string>());
//     unitSdkCfg.perVideoProcessTimeS = std::stoi(jsCfgItem["pervideo_process_time_s"].get<std::string>());
//     unitSdkCfg.frameNumber = std::stoi(jsCfgItem["frame_number"].get<std::string>());
//     //set sdk ,string to enum
//     //unitSdkCfg.enumInputProcessEnable = enumCvt.String2Enum_INPUT_SOURCE_PROCESS_ENABLE(jsReadFunction["process_enable"].get<std::string>());
//     unitSdkCfg.enumInputProcessEnable = INPUT_SOURCE_PROCESS_ENABLE_ENABLE;
//     unitSdkCfg.enumSdkModule = enumCvt.String2Enum_SDK_MODULE(jsReadFunction["sdk_module_type"].get<std::string>());
//     unitSdkCfg.enumInputFunctionType = enumCvt.String2Enum_INPUT_SOURCE_FUNCTION_TYPE(jsReadFunction["sdk_function_type"].get<std::string>());
//     if ((unitSdkCfg.enumInputProcessEnable == INPUT_SOURCE_PROCESS_ENABLE_INVALID) ||
//         (unitSdkCfg.enumSdkModule == SDK_MODULE_INVALID) ||
//         (unitSdkCfg.enumInputFunctionType == INPUT_SOURCE_FUNCTION_TYPE_INVALID)) {
//         LOG_ERROR("get functionTxt content to enum error!, functionPath:%s\n", pathFunctionTxt.c_str());
//         exit(1);
//     }  
// }
// SourceAdapt::SourceAdapt(const std::string& pathInput, const std::string& strFunctionTxtName, const std::string& strSdkRunCfgTxtName) {
//     this->pathRootDir = pathInput;
//     this->strFunctionTxtName = strFunctionTxtName;
//     this->strSdkCfgTxtName = strSdkRunCfgTxtName;
//     //judge if dir
//     if (false == IsDir(pathRootDir)) {
//         LOG_ERROR("input path not a dir, error!\n");
//         exit(1);
//     }
//     //judge path
//     if(strFunctionTxtName.size() == 0 || strSdkCfgTxtName.size() == 0){
//         LOG_ERROR("txtName set error,\n strFunctionTxtName:%s,\n strSdkCfgTxtName:%s\n",this->strFunctionTxtName.c_str(),this->strSdkCfgTxtName.c_str());
//         exit(1);
//     }
//     //get txt list
//     std::vector<std::string> vecSuffix{ ".txt" };
//     GetFileListRecursion(pathRootDir, vecTxt, vecSuffix);
//     if (0 == vecTxt.size()) {//if vecTxt size() == 0
//         LOG_ERROR("can't search txt file from dir_path:%s\n", pathRootDir.c_str());
//         exit(1);
//     }
//     VecFileter(vecTxt, vecFunctionTxt, this->strFunctionTxtName);
//     if (0 == vecFunctionTxt.size()) {//if vecFunctionTxt size() == 0
//         LOG_ERROR("can't search function_txt file from vecTxt!\n");
//         exit(1);
//     }
//     //push source
//     for (std::string tempStr : vecFunctionTxt) {
//         PushOneSource(tempStr);
//     }
      
// }
// SourceAdapt::~SourceAdapt() {
    
// }ff
// CfgAdapt::CfgAdapt() {
    
// }
// CfgAdapt::~CfgAdapt() {
    
// }
// bool CfgAdapt::IsDir(const std::string& strInPath) {
//     struct stat statBuf;
//     stat(strInPath.c_str(), &statBuf);
//     if (S_ISDIR(statBuf.st_mode))
//         return true;
//     else
//         return false;
// }
// bool CfgAdapt::IsFileExist(const std::string& strInPath) {
//     FILE* pFile = NULL;
//     pFile = fopen(strInPath.c_str(), "r");
//     if (NULL == pFile) {
//           fclose(pFile);
//           return false;
//     }
//     else {
//           fclose(pFile);
//           return true;
//     }
// }
// void CfgAdapt::VecFileter(std::vector<std::string>& vecInput, std::vector<std::string>& vecOutput, const std::string& strfield) {
//     int countSuccess = 0;
//     for (std::string temStr : vecInput) {
//         if (temStr.find(strfield.c_str()) != std::string::npos) {
//             vecOutput.push_back(temStr);
//             countSuccess++;
//         }
//     }
// }
// std::string CfgAdapt::GetCurrentDir(const std::string pathInFile, const std::string strSeparator) {
//     //need judge get path if dir
//     if(pathInFile.rfind(strSeparator.c_str()) == std::string::npos){
//         LOG_ERROR("can't find [%s], in path:%s\n", strSeparator.c_str(), pathInFile.c_str());
//         exit(1);
//     }
//     std::string pathDir = pathInFile.substr(0, pathInFile.rfind(strSeparator.c_str()));
//     return pathDir;
// }
// void CfgAdapt::GetMetiralVec(const std::string pathDirInput, const std::vector<std::string> vecSuffix, std::vector<std::string>& vecOut) {
//     GetFileListRecursion(pathDirInput, vecOut, vecSuffix);
// }
// void CfgAdapt::GetTxtContent(const std::string pathTxt, std::string& strTxtContent, bool isOneLine) {
//     std::ifstream inStmTxt(pathTxt);
//     std::string tempStr;
//     if(true == isOneLine){
//         while (std::getline(inStmTxt, tempStr)) {
//             strTxtContent = tempStr;
//             break;
//         }
//     } 
//     else{
//         while (std::getline(inStmTxt, tempStr)){
//             strTxtContent = strTxtContent + tempStr;
//         }
//     }
//     inStmTxt.close();
// }
// void CfgAdapt::GetCfgStruct(const std::string inStrTxtContent, std::string strCfgKey, CfgStruct& outCfgSturct) {
//     EnumCvt enumCvt;
//     json jsRead;
//     json jsItemCfg;
//     jsRead = json::parse(inStrTxtContent);
//     jsItemCfg = jsRead[strCfgKey];
//     if (jsItemCfg["set_param_key_array"].size() != jsItemCfg["set_param_value_array"].size()) {
//         LOG_ERROR("read cfg content error! key_array.size() %d != value_array.size() %d\n", jsItemCfg["set_param_key_array"].size(), jsItemCfg["set_param_value_array"].size());
//         LOG_ERROR("cfg item string:%s\n", jsItemCfg.dump(4).c_str());
//         exit(1);
//     }
//     if (jsItemCfg["set_param_key_array"].size() == 0) {
//         LOG_ERROR("read cfg content, can't find  the cfgItem for %s, the cfg:%s\n", strCfgKey.c_str(), jsRead.dump(4).c_str());
//     }
//     else {
//         for (std::string strItem : jsItemCfg["set_param_key_array"]) {
//             outCfgSturct.vecAlgParamType.push_back(static_cast<ARC_ALG_PARAM_TYPE>(std::stoi(strItem.c_str())));
//         }
//         for (std::string strItem : jsItemCfg["set_param_value_array"]) {
//             outCfgSturct.vecAlgParamValue.push_back(std::stoi(strItem.c_str()));
//         }
//         LOG_INFO("get the cfgItem to cfgStruct, content:%s\n", jsItemCfg.dump(4).c_str());
//     }    
// }